// Copyright (c) 2022 The Brave Authors. All rights reserved.
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// you can obtain one at http://mozilla.org/MPL/2.0/.

#pragma once

#include "third_party/skia/include/core/SkColor.h"

namespace nala::light {
<%= groupedTokens.light.allTokens.map(prop => {
  return `constexpr SkColor ${prop.name} = ${prop.value};`;
}).join('\n') %>
} // namespace nala::light

namespace nala::dark {
<%= groupedTokens.dark.allTokens.map(prop => {
  return `constexpr SkColor ${prop.name} = ${prop.value};`;
}).join('\n') %>
} // namespace nala::dark

namespace nala {

<%= groupedTokens.rest.allTokens.map(prop => {
  return `constexpr SkColor ${prop.name} = ${prop.value};`;
}).join('\n') %>

enum class Theme {
  kLight,
  kDark
};

enum class Color {
<%= groupedTokens.light.allTokens.map(p => `  ${p.name}`).join(',\n') %>,
<%= groupedTokens.rest.allTokens.map(p => `  ${p.name}`).join(',\n') %>
};

constexpr SkColor GetColor(Color color, Theme theme) {
  switch (color) {
<%= groupedTokens.light.allTokens.map(prop => `    case Color::${prop.name}:
      return theme == Theme::kLight
        ? nala::light::${prop.name}
        : nala::dark::${prop.name};`).join('\n') %>
<%= groupedTokens.rest.allTokens.map(prop => `    case Color::${prop.name}:
      return ${prop.name};`).join('\n') %>
    default:
      return SK_ColorRED;
  }
}

} // namespace nala
